**内核旁路**：将I/O管理（例如网络包的收发、磁盘读写、数据库事务执行等）移入用户空间，绕过内核，直接与设备交互

问题：绕过操作系统级的资源管理策略，在面对不受信任和潜在恶意的应用程序时会对设备硬件造成影响

解决方法：允许传统上在内核中实现的服务被封装为**用户空间中**的**受保护库**。将多个互不信任的库加载到同一个地址空间中，为每个库（及主应用程序）提供不同的代码和数据“视图”，并保护每个库免受其他库中的故障影响。

## 内核旁路面临的威胁

### 主要设计

* 应用程序将其整个虚拟内存空间与每个受保护库共享（默认），或只将部分 buffer与受保护库共享（可选）

  但应用程序不能访问受保护库的内部数据或代码，只能访问跳板代码（Hodor 提供的调用入口）

<img src="..\..\assets\image-20250618030947575.png" alt="image-20250618030947575" style="zoom:50%;" />

* **静态链接** protected library 及其依赖 的方式，在编译时将所有函数和符号完全打包在库内部，只暴露 trampoline 接口

* 如果使用共享库（dynamic linking），也应为每个 protection domain 加载该共享库的独立副本（在传统的操作系统中，一份.so文件：磁盘 > 内存后，多个应用程序各自的虚拟地址指向同一份的.so文件所在内存；hodor中，多个应用程序各自的虚拟地址指向各自的.so文件所在内存——这些内存都是磁盘中.so文件的副本）

### 面临的威胁

#### 篡改虚拟地址映射

Hodor 中，受保护库虽然逻辑上被隔离了，但在物理上仍映射在整个进程的虚拟地址空间中

主应用程序（我们自己写的功能）可以用 `mmap` 修改库的代码页映射，从而修改与其处于同一进程，因此处于同一虚拟地址空间的受保护的库的内存

**解决：**

只有当系统调用是在受保护库内部发起时，才允许修改该库的地址空间映射或权限

当请求加载一个受保护库时，它们会将受保护库的代码和数据使用的虚拟地址通知操作系统。在随后的mprotect、mmap等调用中，内核识别发出系统调用的上下文（是否是在受保护库内部发起的？），内核仅在适当的上下文中授予更改受保护库空间的映射或权限的请求

#### 利用线程本地堆栈泄露或篡改库内部变量

攻击者或不可信线程可能访问或破坏正在执行受保护库代码的线程的栈空间，如修改局部变量或返回地址。使其跳到受攻击者控制的代码执行

**解决：**

* 保护域的独立栈

  * 为每个保护域分配独立栈（如网络库栈、存储库栈），当应用程序创建新**线程**时，我们必须为应用程序中的每个域创建一个新的栈，当应用程序调用受保护库的函数时，程序进入目标库的隔离内存空间，并使用目标库对应的线程私有栈

* 跨保护域栈切换

  不同保护域间不信任，怎么切换栈？

  * 将源域的状态（rsp、fs等）保存在仅在源域中可访问的域状态页面中
  * 将地址空间视图切换到目标域
  * 将目标域的状态从仅对目标可访问的域状态页面还原

#### 通过劫持加载机制获得非法访问

攻击者尝试在加载阶段或运行时通过替换或插入恶意库，篡改受保护库的地址空间或访问权限

**解决**

* 以 root 身份运行、受信任的加载器使用mmap系统调用将所有受保护的库映射到虚拟地址空间
* 调用每个受保护库中的初始化函数（在此功能中，库可以打开并映射所需的设备文件，以便对设备的内存映射I/O寄存器或持久或共享内存区域进行直接读/写访问），初始化函数还分配第一个栈，初始化堆，并为受保护的库调用构造函数（例如，用于C++全局变量）
* 加载器使用系统调用通知内核每个受保护库的位置，以便内核对配置虚拟地址空间的系统调用实施限制（2.2）
* 加载器加载应用程序代码和所有其他预加载的动态库
* 加载器使用setresuid系统调用删除根权限，运行应用程序的构造函数，并将控制权转移到应用程序的主例程

#### 通过 signal handler 获得敏感执行上下文

| 概念     | 英文术语          | 定义                                                         | 示例                                                         |
| -------- | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **发送** | signal generation | 某个线程或进程**向另一个线程/进程发出信号的动作**，表示“我要给你一个信号”。这只是“请求”或“挂号”信号，还没真正打断对方执行。（只是将其先交给内核，由其决定什么时候投递） | `kill(pid, SIGINT)``raise(SIGUSR1)`定时器超时自动生成 `SIGALRM` |
| **投递** | signal delivery   | **内核决定什么时候把信号真正发给目标线程**，并安排它去执行信号处理函数（如果有）。这是信号的实际“生效”点，可能中断目标线程正在运行的代码。 | 某线程正在执行时，内核决定现在投递 `SIGUSR1`，于是 handler 马上执行 |
| **接收** | signal handling   | **被投递信号的线程执行信号处理函数的过程**。这时该线程已被打断，进入用户注册的 handler（或默认处理行为），处理完后再回到原来代码。 | `void handler(int sig) { ... }` 被执行                       |

在受保护库执行期间，如果内核将异步信号投递给当前线程，并立即执行攻击者注册的信号处理函数，那么该处理函数可能会运行在受保护库的私有上下文（如私有栈和寄存器状态）中，从而造成对敏感数据的访问和泄露

**解决**

* 在 trampoline 中设置硬件 watchpoint，只有当代码执行到“退出受保护库”的边界位置（`BOUNDARY_TRAMP`）后，才允许发送信号或终止进程
* 如果库长时间未退出，则触发超时机制，视为库失效，清理状态，防止影响其他实例
* 不允许为受保护库注册信号处理函数

## 内存隔离实现

 **Intel Protection Keys for Userspace（PKU）——用户空间内存保护密钥**

* 在页表项（PTE）中有 4 个之前未使用的位（bit），现在被用于保存一个 **protection key**，总共最多支持 16 个不同的 key（0~15）
* CPU 增加了一个 32 位的新寄存器 `pkru`（Protection Key Rights for Userspace），这个寄存器中，每两个 bit 表示对某一个 key 的访问控制

| Key 编号 | pkru 中的 bit | 含义                          |
| -------- | ------------- | ----------------------------- |
| 0        | bit 0-1       | 禁止读 / 写 页表中 key=0 的页 |
| 1        | bit 2-3       | 禁止读 / 写 页表中 key=1 的页 |
| …        | …             | 最多支持 16 个 key            |

* 每次访问内存：看访问的虚拟地址是哪一页 > 查该页的 PTE，读出它的 key 值 > 用 key 去查 `pkru` 寄存器，看是否被禁止读或写 > 如果被禁止，就拒绝访问（触发段错误）
* 当代码从主应用程序进入受保护库时，用户程序可以调用 `WRPKRU` 指令来修改 `pkru` 寄存器，改变对各个 key 的访问权，在用户态就可以实现主应用程序和各受保护库之间内存的隔离

（每个key代表一个权限组，只要修改`pkru`中这一组的权限，则修改了关联这一组的全部页表项的权限）



























保护多个不互信库之间的内存访问安全的进程内隔离机制

| 属性             | **Hodor**                                            | **Library OS（LibOS）**                                 |
| ---------------- | ---------------------------------------------------- | ------------------------------------------------------- |
| 核心目标         | 提供用户态服务的**隔离机制**，防止同一进程内库间攻击 | 把“一个完整的操作系统抽象”封装为一个用户态库            |
| 安全关注点       | 多个“用户态内核服务”之间相互隔离                     | 一个应用封装自己的“操作系统”服务，重点是兼容性 & 移植性 |
| 应用和服务关系   | 多个应用/库共用一套内核（Hodor 下的 Linux）          | 每个应用**拥有自己的 LibOS 内核**                       |
| 是否需要修改应用 | 不需要，支持现有 app 调用 trampoline                 | 可能需要（特殊 ABI、接口）                              |
| 所在进程关系     | 受保护库和主程序在**同一进程**                       | 应用和 LibOS 一起运行，通常是**单独一个进程/沙箱**      |
| 代表项目         | Hodor（2019, USENIX ATC）                            | Drawbridge、Graphene、Unikraft、IncludeOS、MirageOS 等  |

LibOS 能用 Hodor 来加强自身安全隔离
