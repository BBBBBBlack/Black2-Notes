* insmod实用程序将模块对象文件（编译后的内核模块二进制文件，.ko）读入内存，通过系统调用（如`mmap`）将文件内容映射到内存中，获得一个内存区域的句柄（handle，相当于一个指针）,并将其传递给sys_init_module系统调用

* sys_init_module调用load_module函数

  * 分配一个临时内存区域，并将内存句柄指示的内容复制到临时区域。然后，检查模块的先前版本是否存在，如果存在先前版本，则设置热插拔标志

  * 如果设置了热交换标志，则跟踪系统中每个进程的内核堆栈。如果在进程堆栈中找到此模块的任何功能，请重试，直到达到阈值

  * 将模块对象文件分为三部分，计算每种部分类型的总大小：

    * 核心节：模块的运行时核心部分，热替换时完全更新
    * 初始化节：临时性数据，加载后即可释放
    * 静态地址节：需保持地址不变的变量（如模块描述符），热替换时复用旧地址——例如.gnu.linkonce.his_module

    如果未设置热插拔标志，则分配三个内存区域，分别用于核心部分、初始部分和静态地址部分。否则，只分配核心部分和初始部分，因为静态地址部分的内存是从以前的版本继承的

  * 根据之前的分类，将每个部分复制到内存的适当区域

  * 解析每个未定义的模块符号。首先，查找内核符号表，然后查找模块符号表。如果未定义的符号名称以_old_开头，则将其附加到先前版本中定义的相应符号

  * 在成功解析所有符号后执行重新定位。重定位计算代码和数据的地址

  * 将热交换所需的信息保存到replace_handle结构中，并将该结构添加到名为module_handle的列表中。replace_handle结构保留了静态地址段、动态解析和重定位以及模块描述符管理所需的重要信息

  * 如果未设置热插拔标志，请释放临时内存区域，并将模块描述符返回给其调用者

* 