## 最小特权原则

* 控制流完整性：不允许隔离环境内的执行流程被重定向到未经授权的目标代码——间接调用、跳转指令的目的地、栈的返回地址要合法

* 数据完整性：确保访问的对象位于正确的区域并且**类型适当**

  * 为什么要类型适当？

    组件释放一块内存 > 被释放的内存块会被放入内存池或 slab 中，成为“空闲可复用”的空间 > 这块内存被重新分配给别的组件（甚至攻击者伪造的结构体） > 原本释放该内存的组件再次访问这块内存（可能是异步操作引起的） > 错误解析造成信息泄露

* 授权的参数和返回值 - 分区禁止传递恶意参数或返回恶意值给其余内核

## Design

<img src="..\..\assets\image-20250707211346123.png" alt="image-20250707211346123" style="zoom:90%;" />

### 阶段-1

（检查目标的确定）

* **代码分析器**检查内核源代码及其运行时二进制文件，识别需要强制进行分隔的指令，如内存访问
  * Indirect Transfer：`ret`、`jmp xxx`等；代码分析器记录其地址（func + offset）及其目标地址存储的位置，用eBPF map存储——代码地址：目标地址
  * Memory Access：`move`、`store`、`load`、`comparison`、`arithmetic`；代码分析器记录其地址及其访问内存的地址
  * Subject Switching：分区调用内核剩余部分的函数/内核剩余部分调用分区函数（防止分区向外传递恶意参数或向外返回恶意值；防止分区的故障向外传播）；代码分析器识别那些可以被外部调用的内部函数和可调用外部函数的内部指令
* **代码分析器**促使**对象剖析器**对内核对象的内容进行标签标注，以作为机器学习（ML）模型的训练数据

### 阶段0

（检查的执行）

<img src="..\..\assets\image-20250707221913087.png" alt="image-20250707221913087" style="zoom:80%;" />

将受攻击组件转换为分区状态：

* 将eBPF程序编排到阶段-1识别出的需要强制进行分隔的指令

  * 控制流完整性

    阶段-1分析Indirect Transfer存储的Map在专用于控制流完整性的eBPF程序之间共享，当从寄存器中提取跳转或返回指令的目标地址时，eBPF将其与Map中存储的目标地址比较

  * 数据完整性

    * 私有栈和堆

      创建栈：在进入易受攻击组件的入口函数时，插入的eBPF创建私有栈（obtaining memory from the buddy system which manages the entire computer’s physical memory）

      管理堆：将eBPF程序插入分配与释放内存的指令——根据请求内存的类型不同，使用不同的内存分配方式（buddy system、SLAB/SLUB分配器、vmalloc分配器）

    利用阶段-1的Memory Access检查运行时访问的内存地址有无偏差

    * 堆对象跟踪与类型分析

      堆对象已经被记录在 map 中，O2C 可以直接查询该映射表来验证对象的类型

      * Buddy系统：map记录了代码中分配该对象的位置——通过“哪个函数或调用点分配了它”来间接推断它是什么类型的对象
      * SLAB/SLUB分配器：map记录了存储该对象的的slab cache——每个 cache 通常只存储某一类特定大小和类型的对象。因此如果知道对象在哪个 cache 中，就基本知道其类型
      * vmalloc分配器：map记录了与所分配的内存（虚拟地址连续的大内存块）对应的`vm_struct`结构的地址——通过读取`vm_struct`存储的内存区域的元数据结构，获取对象类型
      * 那些在分区前就被创建的对象——使用**ML**

  * 授权参数和返回值

    将eBPF程序插入阶段-1识别出的Subject Switching指令，进行检查

* 为组件创建私有堆和栈

* 控制subject转移

* 验证相应位置的分隔特性

* 利用在阶段-1中生成并嵌入到eBPF程序中的ML模型进行审核。当检测到异常时，O2C记录关键信息以供事后分析

* 

### 阶段1

* 分区中所有对象被追踪
* 禁用ML模型

## 一些优化

减少需要探测的指令数量

* 跳过确定性地址
* 消除冗余检查
* 忽略低风险的读取操作
* 快捷堆检查

## ML的具体实现

运行时，遇到指针解引用操作：获取引用操作的内容，使用ML模型推测其类型，和阶段0检测出的类型比较，若不匹配，则监听此恶意活动以进行事后分析

O2C 不在对象访问时就尝试识别其类型，而是等到对象释放时才进行“审计”（audition）

| 原因                           | 解释                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 🎯 **刚分配时的数据不可辨识**   | 对象刚分配出来时内容是清零的或是随机垃圾值，不能准确判断其类型 |
| 📈 **使用过程中数据逐渐“定型”** | 生命周期中，内核会不断往对象中写入字段，慢慢形成有特征的数据结构 |
| ✅ **释放时信息最全面**         | 到释放时，对象内存内容最完整、最能反映真实用途，因此最适合做机器学习推断 |

### 收集训练数据：对象剖析器

* 在阶段-1收集
* 在内存分配位置插入eBPF程序：记录创建的对象的地址、调用路径（哪个函数调用了分配）；代码分析器根据调用路径推断其类型，将（地址：类型）存入map
* 在内存释放位置插入eBPF程序：存储对象内容，在map中查找其类型，为对象内容打上标签

| 步骤       | 动作                                      | 使用的 eBPF 插点 |
| ---------- | ----------------------------------------- | ---------------- |
| 1️⃣ 分配时   | 记录对象地址和调用路径 → 得到类型         | allocation site  |
| 2️⃣ 存储     | 将 <地址，类型> 写入 BPF map              | —                |
| 3️⃣ 释放时   | dump 对象内容 + 查询地址得知类型 → 打标签 | free site        |
| 4️⃣ 整体策略 | 收集覆盖整个内核，不限于隔离组件          | 全局 hook        |

### ML模型：决策树

* 在处理表格上有优势
* 可解释性、有确定性的推理时间
* eBPF不支持浮点计算和动态堆

### 数据处理

将内核对象的内容按照每 8 字节一组（即一个 quad word）进行切分，形成一个序列

填充0来标准化其长度

### ML嵌入eBPF

将模型训练好后，使用scikit-learn将模型转化为5个数组

| 数组名            | 含义                                                 |
| ----------------- | ---------------------------------------------------- |
| `childrenLeft[]`  | 节点 i 的左子节点编号，若为 -1 表示为叶子节点        |
| `childrenRight[]` | 节点 i 的右子节点编号，若为 -1 表示为叶子节点        |
| `feature[]`       | 节点 i 比较的特征维度（对应 quad word 的索引）       |
| `threshold[]`     | 节点 i 的判断阈值（例如：如果 `feature[3] ≤ 100`）   |
| `value[]`         | 若该节点是叶子节点，则这个值表示预测结果（对象类型） |

将5个数组作为map载入内核

eBPF 程序实现推理逻辑

与静态分析结果对比