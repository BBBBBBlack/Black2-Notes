# KFlex

## 目标属性

* 安全性：
  * 内核接口合规性（kernel-interface compliance）：扩展仅在允许的情况下访问内核拥有的资源 —— 即内核内存和内核函数
  * 扩展正确性（extension correctness）：扩展可以安全地访问自己的内存并正确终止

* 灵活性：用户能够在他们的扩展中表达不同的功能
  * 内核向扩展公开的接口
  * 开发人员编写扩展时可用的编程模型
* 性能：
  * 扩展作为内核的一部分执行时的低运行时开销
  * 扩展与用户空间中的应用程序交互时的低通信开销
* 实用性：用户不应该学习新的编程语言或使用特定的工具链来编写内核扩展、向后兼容

### 现有方法的缺陷

* 安全语言：用类型和内存安全的语言编写新的操作系统
* 软件故障隔离（SFI）：在软件层面插入检查代码，把不可信代码的执行“沙箱化”
* 静态验证：在扩展加载到内核之前自动验证其安全性
  * 不允许拓展自定义数据结构
  * 不能使用没有静态边界的循环

<img src="..\..\assets\image-20250630021740855.png" alt="image-20250630021740855" style="zoom:50%;" />

## 设计

内核接口合规性（kernel-interface compliance）——自动验证

扩展正确性（extension correctness）——运行时检查

<img src="..\..\assets\image-20250630030219044.png" alt="image-20250630030219044" style="zoom:60%;" />

* 将eBPF字节码传入内核，使用Verifier对其做**内核接口合规性**检查
* 使用插桩引擎（Kie，利用eBPF验证器的范围和循环终止分析来减少发出的检测，从而降低运行时开销），对eBPF字节码做插桩——**扩展正确性**
* JIT将插桩后的字节码编译为机器指令，并执行（eBPF运行时会执行插桩的代码，实现运行时检查），KFlex在内核虚拟地址空间的专用部分中分配扩展拥有的内存，从而消除了内核拥有和扩展拥有内存之间的内存混叠（`kflex_heap(size)`）



* KFlex没有静态验证中的几个约束
* 新增约束：在循环迭代中获取的任何内核资源也必须在迭代结束时释放

### 轻量级SFI

KFlex 引入了扩展 heap、共享对象等新资源，它们只对扩展程序可见，如果扩展访问这些资源越界或死循环，可能导致程序崩溃或安全问题，故需要通过 SFI 的方式，把扩展程序的资源访问控制在“安全范围”内：

* SFI实现方式：kie的插桩
  * 死循环
  * 越界访问：exp —— 对于解引用指针进行**sanitize**：真实地址 >> mask(真实地址) >> mask(真实地址) + 堆的基地址

​				——保证不会越界访问，同时相比于在发生越界访问时进行陷阱和取消扩展的方式，开销更小

​	优化：如果 verifier 已经证明某次 heap 访问是安全的，就不插入 runtime 检查代码，节省开销

性能模式：在读数据时，sanitize可选（保密性 or 性能）；在写数据时，一定要sanitize（安全性，防止越界访问）

### 扩展取消（Extension Cancellations）

不变量（invariants）——操作系统执行过程中始终应当保持为真的条件

| 场景                 | 不变量示例                                      | 说明                       |
| -------------------- | ----------------------------------------------- | -------------------------- |
| 🔄 **内核引用计数**   | `refcount ≥ 0` 且 `资源未释放前 refcount ≠ 0`   | 防止资源提前释放或内存泄露 |
| 🔐 **锁的使用**       | `一个线程持有锁 ⇒ 其他线程必须等待`             | 保证临界区互斥             |
| 📦 **socket 状态**    | `TCP socket 从 ESTABLISHED → FIN_WAIT → CLOSED` | 遵循状态机，不可跳跃       |
| 🧩 **map entry 使用** | `插入前 key 不存在；删除后不能再访问`           | 保持一致性                 |

Quiescent state——扩展执行完毕后，系统内部的数据结构、内核对象处于一致、稳定、可恢复工作的状态

**扩展取消**——终止长时间运行的扩展，并在终止时安全地释放扩展获取的任何内核拥有的对象（例如引用计数器、锁），以符合内核不变量

#### cancellation points (Cps)

——代表扩展代码中的指令，当需要时，它将在这些指令处终止扩展

* **C1**：扩展代码中所有循环的回边，对于这些回边，无法静态保证终止  >> 可能造成无限循环
* **C2**：对扩展堆的访问 >> SFI 确保堆访问在边界之内，但并不保证被访问的页面具有有效的物理地址
* 扩展执行helper functions时，不能终止

执行——KFlex 通过在 C1 的后边缘添加堆访问，将两类 Cps 合并为一类

#### Object table (对象表)

——每个Cp有一个，记录扩展在此时占有的内核资源（栈、寄存器、对象）

**计算**：通过helper functions

**构建**：在扩展程序加载前，通过静态分析（symbolic execution）构建好，在插桩（instrumentation）时绑定到每个程序点 Cp

#### 取消过程

* C1：
  * KFlex运行时监控扩展的执行时间，当执行时间超过预期时间量时，将用于堆访问的地址归零
  * 触发Cp处堆访问异常
  * 捕获异常，遍历对象表，依次调用表中资源的析构函数
* C2：捕获堆访问异常，遍历对象表，依次调用表中资源的析构函数

### 与用户空间通信

用户空间代码能够请求将扩展堆映射到它们的地址空间 >> 从而通过虚拟内存直接和透明地访问所有扩展状态，避免了系统调用

* 挑战一：扩展和用户空间进程的虚拟地址空间不一致（指针不能互换着用）

  Kie在存储指针时，将这个指针转换为**在用户空间中有效的地址**（在 “写 pointer 的地方” 插入地址转换代码，而真正的用户空间地址只有在运行时才能确定）

* 挑战二：在内核中运行的扩展可以随时抢占其用户空间对应的进程

  为了避免用户程序在临界区被扩展抢占导致死锁，KFlex 允许它暂时延长调度时间片，尽快完成临界区执行
