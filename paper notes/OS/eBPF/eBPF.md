# eBPF



* **用户编写 C 程序** ➜ `clang -target bpf` 编译成字节码（.o 文件）；
* **字节码被加载到内核**（通过 `bpf()` 系统调用）；
* **Verifier 验证程序是否合法**（是否访问越界、死循环、非法 helper 调用）；
* **JIT 编译成机器码**（可选）；
* **eBPF VM 调用字节码指令**，从主 subprog 执行。



### eBPF字节码

 一组有序的 eBPF 指令

|      类型       |            示例            |                         功能                         |
| :-------------: | :------------------------: | :--------------------------------------------------: |
|  **算术/逻辑**  | `add`, `sub`, `and`, `xor` |                 对寄存器进行基本运算                 |
|  **内存访问**   |  `ldx`, `stx`, `ldimm64`   |            从 map 或内核结构读取/写入数据            |
|    **跳转**     | `ja`, `jeq`, `jgt`, `jne`  |                支持条件跳转、函数调用                |
| **调用 helper** |           `call`           | 调用内核提供的 helper 函数，例如访问 map、获取时间戳 |
|    **退出**     |           `exit`           |                终止程序执行并返回结果                |
|  **加载常量**   |      `mov`, `ldimm64`      |               向寄存器加载立即数或地址               |

程序结构

```
eBPF Program (入口主函数)     
│
├── Subprog 1（函数 A）
│
├── Subprog 2（函数 B）
│   └── 可由 Subprog 1 或主程序调用
│
└── Subprog 3（可内联）
```



### eBPF用户空间加载器

* 使用BPF_PROG_LOAD系统调用将eBPF字节码加载到内核中
* 创建 map，返回一个文件描述符fd

* 可用这个 `fd` 将程序 attach 到 hook（如 kprobe、XDP 等）

#### map

eBPF 与用户空间之间交换数据的“共享容器”，驻留在内核中

也可以在多个 eBPF 程序之间共享信息

* 用户空间通过**文件描述符 `fd`** 可以读写它 —— 使用 `bpf()` 系统调用（或 `libbpf` 封装）对这个 map 执行插入、删除查询等操作
* eBPF通过**指向map的指针** —— 使用 helper 函数（如 `bpf_map_lookup_elem`, `bpf_map_update_elem`）来访问 map

#### hook

内核事件触发器

|            hook 类型             |             描述              |            常见用途             |
| :------------------------------: | :---------------------------: | :-----------------------------: |
|          **Tracepoint**          |      内核预定义的事件点       |   性能分析、追踪函数入口/退出   |
|       **kprobe/kretprobe**       |  任意内核函数的入口或返回点   |     系统调用监控、行为审计      |
|   **XDP（eXpress Data Path）**   |  网络包到达网卡时的早期 hook  | DDoS 防护、负载均衡、数据包过滤 |
|    **TC（Traffic Control）**     | 网络数据包在 socket 层的 hook |     QoS、延迟优化、流量控制     |
| **LSM（Linux Security Module）** |         安全策略 hook         |   强化访问控制（如 bpf-lsm）    |
|         **cgroup hook**          |      控制组的资源访问点       |   限制特定进程网络、内存行为    |
|       **Uprobe/Uretprobe**       |  用户空间程序函数的入口/返回  |       分析用户态程序行为        |

#### helper

eBPF 程序必须通过 helper调用内核函数

#### link

把“程序挂载到 hook”的操作变成了一个真实的、可控的内核资源对象（有文件描述符`fd`的对象），可以像操作文件一样操作这个绑定关系

### eBPF验证器

在字节码被接受到内核之前对其进行检查，确保与eBPF相关的安全属性，并且程序的加载在任何情况下都不会对内核的完整性和安全性产生负面影响。



### eBPF实时编译器和解释器

验证过程完成后，使用准时制（JIT）编译器将程序编译为本机机器指令。

在禁用或不支持JIT的情况下，eBPF解释器负责程序执行，实时动态解码和执行字节码。

然后，内核为加载的程序分配一个文件描述符

